---
phase: 01-backend-provider
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/back/boring_ui/api/modules/sandbox/providers/local.py
  - src/back/boring_ui/api/modules/sandbox/providers/__init__.py
  - src/back/boring_ui/api/modules/sandbox/__init__.py

autonomous: true

must_haves:
  truths:
    - "LocalProvider spawns sandbox-agent as subprocess with direct binary path"
    - "Binary path comes from SANDBOX_AGENT_BIN env var with sensible default"
    - "Missing binary fails fast with clear FileNotFoundError at startup"
    - "Logs are captured with ISO timestamps into 1000-line ring buffer"
    - "Health check polls /health endpoint with 500ms interval on startup"
    - "Startup times out after 30 seconds if not healthy"
    - "Shutdown sends SIGTERM then SIGKILL after 5 seconds"
  artifacts:
    - path: "src/back/boring_ui/api/modules/sandbox/providers/local.py"
      provides: "LocalProvider implementation"
      exports: ["LocalProvider"]
      min_lines: 150
    - path: "src/back/boring_ui/api/modules/sandbox/__init__.py"
      provides: "Package exports including LocalProvider"
      contains: "LocalProvider"
  key_links:
    - from: "src/back/boring_ui/api/modules/sandbox/providers/local.py"
      to: "SandboxProvider"
      via: "inheritance"
      pattern: "class LocalProvider\\(SandboxProvider\\)"
    - from: "src/back/boring_ui/api/modules/sandbox/providers/local.py"
      to: "asyncio.create_subprocess_exec"
      via: "subprocess spawn"
      pattern: "create_subprocess_exec"
    - from: "src/back/boring_ui/api/modules/sandbox/providers/local.py"
      to: "httpx.AsyncClient"
      via: "health checks"
      pattern: "httpx\\.AsyncClient"
---

<objective>
Implement LocalProvider that manages sandbox-agent as a subprocess with log capture and health checking.

Purpose: This is the core execution provider for local development. It spawns sandbox-agent, monitors its health, captures logs, and handles graceful shutdown.

Output: LocalProvider class fully implementing SandboxProvider interface with subprocess lifecycle management.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-backend-provider/01-CONTEXT.md
@.planning/phases/01-backend-provider/01-RESEARCH.md
@.planning/phases/01-backend-provider/01-01-SUMMARY.md
@src/back/boring_ui/api/modules/sandbox/provider.py
@src/back/boring_ui/api/modules/pty/service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement LocalProvider subprocess lifecycle</name>
  <files>
    src/back/boring_ui/api/modules/sandbox/providers/local.py
  </files>
  <action>
Create local.py with LocalProvider class implementing SandboxProvider:

**Configuration (from env vars per user decision):**
- SANDBOX_AGENT_BIN: Binary path (default: "sandbox-agent")
- SANDBOX_WORKSPACE: Working directory (default: cwd)
- SANDBOX_HOST: Host to bind (default: "127.0.0.1")
- SANDBOX_PORT: Port to use (default: 2468)

**Constructor:**
- Read config from env vars with defaults
- Initialize state to STOPPED
- Initialize empty log deque with maxlen=1000
- Initialize asyncio.Lock for log access

**start() method (per user decisions):**
1. If already STARTING or RUNNING, return early
2. Validate binary exists using shutil.which() - raise FileNotFoundError with clear message if not found (fail fast)
3. Set state to STARTING
4. Build command: [binary, "server", "--host", host, "--port", str(port), "--no-token"]
5. Spawn with asyncio.create_subprocess_exec:
   - cwd=workspace
   - stdout=PIPE
   - stderr=STDOUT (merge stderr into stdout per user decision)
6. Start background task for _read_output()
7. Call _wait_for_healthy(timeout=30.0) - 30 second timeout per user decision
8. If not healthy: stop and raise TimeoutError
9. Set state to RUNNING

**stop() method (per user decisions):**
1. If already STOPPED, return
2. Set state to STOPPING
3. Cancel read task (handle CancelledError)
4. If process alive:
   - process.terminate() (SIGTERM)
   - await asyncio.wait_for(process.wait(), timeout=5.0) - 5 second grace per user decision
   - If TimeoutError: process.kill() (SIGKILL) then await process.wait()
5. Set state to STOPPED

**_read_output() background task:**
- Loop while process alive
- Read lines with process.stdout.readline()
- Decode UTF-8 (errors='replace')
- Add ISO timestamp prefix: f"{datetime.now(timezone.utc).isoformat()} | {line}"
- Append to log deque under lock
- Handle exceptions gracefully (break on error)

**_wait_for_healthy() method (per user decisions):**
- Small initial delay (200ms) for port binding
- Poll interval: 500ms per user decision
- Use httpx.AsyncClient with 2s timeout
- GET base_url/health, return True on 200
- Ignore ConnectError/TimeoutException (service not ready)
- Return False if deadline exceeded
  </action>
  <verify>
python -c "
from boring_ui.api.modules.sandbox.providers.local import LocalProvider
p = LocalProvider()
assert p.status.value == 'stopped'
assert p.base_url == 'http://127.0.0.1:2468'
print('LocalProvider instantiates OK')
"
  </verify>
  <done>
LocalProvider with start(), stop(), _read_output(), _wait_for_healthy() methods. Binary validation with fail-fast. Subprocess spawn with merged output. 30s startup timeout. SIGTERM/SIGKILL shutdown.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement LocalProvider remaining interface methods</name>
  <files>
    src/back/boring_ui/api/modules/sandbox/providers/local.py
  </files>
  <action>
Add remaining SandboxProvider methods to LocalProvider:

**health_check() async method:**
- Return False if state != RUNNING
- Try GET base_url/health with httpx.AsyncClient(timeout=2.0)
- Return True on 200, False on any exception

**get_logs(tail: int = 100) async method:**
- Acquire log lock
- Return list(self._logs)[-tail:]

**stream_logs() async generator:**
- Simple implementation: yield from buffer
- (Production would use asyncio.Queue for real-time streaming - note in docstring)

**get_info() async method:**
- Return SandboxInfo with:
  - status=self._state
  - base_url=self.base_url
  - healthy=await self.health_check()
  - pid=self._process.pid if self._process else None
  - restart_count=0 (manager tracks this)
  - last_health_check=datetime.now(timezone.utc)

**Properties:**
- base_url: Return f"http://{self.host}:{self.port}"
- status: Return self._state
  </action>
  <verify>
python -c "
from boring_ui.api.modules.sandbox.providers.local import LocalProvider
import asyncio

async def test():
    p = LocalProvider()
    info = await p.get_info()
    assert info.status.value == 'stopped'
    assert not info.healthy
    logs = await p.get_logs()
    assert logs == []
    print('LocalProvider interface complete')

asyncio.run(test())
"
  </verify>
  <done>
LocalProvider fully implements SandboxProvider interface. health_check, get_logs, stream_logs, get_info, base_url, status all working.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update package exports for LocalProvider</name>
  <files>
    src/back/boring_ui/api/modules/sandbox/providers/__init__.py
    src/back/boring_ui/api/modules/sandbox/__init__.py
  </files>
  <action>
Update package exports:

1. providers/__init__.py:
   - Add: from .local import LocalProvider
   - Update __all__ to include LocalProvider

2. sandbox/__init__.py:
   - Add: from .providers import LocalProvider
   - Update __all__ to include LocalProvider

Follow existing PTY module pattern for export organization.
  </action>
  <verify>
python -c "
from boring_ui.api.modules.sandbox import LocalProvider, SandboxProvider
from boring_ui.api.modules.sandbox.providers import LocalProvider as LP
assert LocalProvider is LP
print('Package exports OK')
"
  </verify>
  <done>
LocalProvider exported from both sandbox and sandbox.providers packages.
  </done>
</task>

</tasks>

<verification>
Run from src/back directory:
```bash
cd src/back

# Add httpx to dependencies if not present
pip install httpx

# Test LocalProvider
python -c "
import asyncio
import os
from boring_ui.api.modules.sandbox import LocalProvider, SandboxState, SandboxInfo

async def verify():
    # Test instantiation with defaults
    provider = LocalProvider()
    assert provider.status == SandboxState.STOPPED
    assert provider.base_url == 'http://127.0.0.1:2468'

    # Test with custom env
    os.environ['SANDBOX_PORT'] = '3000'
    provider2 = LocalProvider()
    assert provider2.base_url == 'http://127.0.0.1:3000'
    del os.environ['SANDBOX_PORT']

    # Test get_info
    info = await provider.get_info()
    assert isinstance(info, SandboxInfo)
    assert info.status == SandboxState.STOPPED
    assert not info.healthy

    # Test get_logs
    logs = await provider.get_logs()
    assert isinstance(logs, list)

    # Test health_check when stopped
    healthy = await provider.health_check()
    assert not healthy

    print('All LocalProvider verifications passed')

asyncio.run(verify())
"
```
</verification>

<success_criteria>
- [ ] LocalProvider inherits SandboxProvider and implements all abstract methods
- [ ] Binary path from SANDBOX_AGENT_BIN with default "sandbox-agent"
- [ ] shutil.which() validation with clear FileNotFoundError on missing binary
- [ ] asyncio.create_subprocess_exec with stdout=PIPE, stderr=STDOUT
- [ ] Log capture with ISO timestamps, 1000-line ring buffer (deque maxlen=1000)
- [ ] Health check via httpx.AsyncClient to /health endpoint
- [ ] 30-second startup timeout with 500ms polling interval
- [ ] SIGTERM then SIGKILL after 5 seconds on shutdown
- [ ] All package exports working
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-provider/01-02-SUMMARY.md`
</output>
