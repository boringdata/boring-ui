---
phase: 01-backend-provider
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/back/boring_ui/api/modules/sandbox/manager.py
  - src/back/boring_ui/api/modules/sandbox/__init__.py

autonomous: true

must_haves:
  truths:
    - "SandboxManager starts provider at construction time (eager startup)"
    - "Crash recovery uses exponential backoff: 1s, 2s, 4s, max 3 attempts"
    - "Health monitoring runs every 10 seconds in background"
    - "3 consecutive health failures trigger restart"
    - "Manager exposes ensure_running, stop, get_info methods"
  artifacts:
    - path: "src/back/boring_ui/api/modules/sandbox/manager.py"
      provides: "SandboxManager orchestration"
      exports: ["SandboxManager"]
      min_lines: 100
    - path: "src/back/boring_ui/api/modules/sandbox/__init__.py"
      provides: "Full package exports"
      contains: "SandboxManager"
  key_links:
    - from: "src/back/boring_ui/api/modules/sandbox/manager.py"
      to: "LocalProvider"
      via: "composition"
      pattern: "self\\.provider.*=.*LocalProvider"
    - from: "src/back/boring_ui/api/modules/sandbox/manager.py"
      to: "exponential backoff"
      via: "crash recovery"
      pattern: "2\\s*\\*\\*\\s*attempt"
---

<objective>
Implement SandboxManager that orchestrates LocalProvider lifecycle with crash recovery and health monitoring.

Purpose: The manager provides the ensure_running pattern expected by API routes. It handles startup with retry, background health monitoring, and automatic restart on failure.

Output: SandboxManager class with exponential backoff retry, health monitoring, and clean shutdown.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-backend-provider/01-CONTEXT.md
@.planning/phases/01-backend-provider/01-RESEARCH.md
@.planning/phases/01-backend-provider/01-02-SUMMARY.md
@src/back/boring_ui/api/modules/sandbox/providers/local.py
@src/back/boring_ui/api/modules/pty/service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SandboxManager with startup and crash recovery</name>
  <files>
    src/back/boring_ui/api/modules/sandbox/manager.py
  </files>
  <action>
Create manager.py with SandboxManager class:

**Class attributes:**
- provider: Optional[LocalProvider] = None
- _monitor_task: Optional[asyncio.Task] = None
- _restart_count: int = 0
- _max_restart_attempts: int = 3 (per user decision)

**Constructor:**
- Initialize attributes
- (No eager startup in __init__ - use start() method for async initialization)

**start() async method (eager startup per user decision):**
1. If provider exists and status is RUNNING, return early
2. Call _start_with_retry()
3. Start health monitoring: _monitor_task = asyncio.create_task(_monitor_health())

**_start_with_retry() async method (per user decisions):**
- Loop up to max_restart_attempts (3) times
- For each attempt:
  - Create LocalProvider()
  - Try provider.start()
  - On success: set self.provider and return
  - On exception (not final attempt):
    - Delay with exponential backoff: 1.0 * (2 ** attempt) seconds (1s, 2s, 4s)
    - Log the retry
  - On final attempt failure: raise RuntimeError with clear message

**stop() async method:**
1. Cancel monitor task (handle CancelledError)
2. If provider exists: await provider.stop()
3. Reset _restart_count to 0

**ensure_running() async method:**
- If provider is None or status != RUNNING:
  - Call start()
- Return provider

This is the primary entry point for routes to ensure sandbox is available.
  </action>
  <verify>
python -c "
from boring_ui.api.modules.sandbox.manager import SandboxManager
m = SandboxManager()
assert m.provider is None
assert m._restart_count == 0
print('SandboxManager instantiates OK')
"
  </verify>
  <done>
SandboxManager with start(), stop(), ensure_running(), _start_with_retry() methods. Exponential backoff: 1s, 2s, 4s. Max 3 attempts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement health monitoring with auto-restart</name>
  <files>
    src/back/boring_ui/api/modules/sandbox/manager.py
  </files>
  <action>
Add health monitoring to SandboxManager (per user decisions):

**_monitor_health() async method:**
- Initialize consecutive_failures = 0
- Loop forever:
  - await asyncio.sleep(10.0) - 10 second interval per user decision
  - Check provider.health_check()
  - If healthy: reset consecutive_failures to 0
  - If not healthy:
    - Increment consecutive_failures
    - If consecutive_failures >= 3 (per user decision):
      - Log unhealthy detection
      - Set provider state to UNHEALTHY
      - await provider.stop()
      - Try _start_with_retry()
      - If restart fails: set provider._state to FAILED, break
      - Reset consecutive_failures
      - Increment _restart_count

**get_info() async method:**
- If no provider: return dict with status='not_started'
- Get provider.get_info()
- Add restart_count from manager (overrides provider's 0)
- Return as dict

Add proper logging using Python logging module:
- logger = logging.getLogger(__name__)
- Log startup attempts, health failures, restarts
  </action>
  <verify>
python -c "
from boring_ui.api.modules.sandbox.manager import SandboxManager
import asyncio

async def test():
    m = SandboxManager()
    info = await m.get_info()
    assert info['status'] == 'not_started'
    print('SandboxManager health monitoring OK')

asyncio.run(test())
"
  </verify>
  <done>
Health monitoring with 10-second interval. 3 consecutive failures trigger restart. Restart uses same exponential backoff. get_info includes restart_count.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update package exports for SandboxManager</name>
  <files>
    src/back/boring_ui/api/modules/sandbox/__init__.py
  </files>
  <action>
Update sandbox/__init__.py:

1. Add: from .manager import SandboxManager
2. Update __all__ to include SandboxManager

Final __all__ should include:
- SandboxProvider, SandboxState, SandboxInfo (from provider.py)
- LocalProvider (from providers/)
- SandboxManager (from manager.py)

Verify import order is correct (provider.py first, then providers, then manager).
  </action>
  <verify>
python -c "
from boring_ui.api.modules.sandbox import (
    SandboxProvider, SandboxState, SandboxInfo,
    LocalProvider, SandboxManager
)
print('All exports available')
"
  </verify>
  <done>
SandboxManager exported from sandbox package. Full package API complete.
  </done>
</task>

</tasks>

<verification>
Run from src/back directory:
```bash
cd src/back
python -c "
import asyncio
from boring_ui.api.modules.sandbox import (
    SandboxManager, SandboxProvider, SandboxState,
    SandboxInfo, LocalProvider
)

async def verify():
    # Test SandboxManager instantiation
    manager = SandboxManager()
    assert manager.provider is None
    assert manager._restart_count == 0

    # Test get_info when not started
    info = await manager.get_info()
    assert info['status'] == 'not_started'

    # Verify all exports are correct types
    assert issubclass(LocalProvider, SandboxProvider)
    assert hasattr(SandboxState, 'RUNNING')
    assert hasattr(SandboxInfo, 'status')

    print('All SandboxManager verifications passed')

asyncio.run(verify())
"
```
</verification>

<success_criteria>
- [ ] SandboxManager with provider: Optional[LocalProvider] attribute
- [ ] start() creates provider and starts health monitoring
- [ ] _start_with_retry() uses exponential backoff: 1s, 2s, 4s delays
- [ ] _start_with_retry() max 3 attempts before raising RuntimeError
- [ ] stop() cancels monitor task and stops provider
- [ ] ensure_running() starts if not running, returns provider
- [ ] _monitor_health() runs every 10 seconds
- [ ] 3 consecutive health failures trigger restart
- [ ] get_info() returns dict with status and restart_count
- [ ] Proper logging for startup/health/restart events
- [ ] SandboxManager exported from sandbox package
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-provider/01-03-SUMMARY.md`
</output>
