---
phase: 01-backend-provider
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/back/boring_ui/api/modules/sandbox/__init__.py
  - src/back/boring_ui/api/modules/sandbox/provider.py
  - src/back/boring_ui/api/modules/sandbox/providers/__init__.py
  - src/back/boring_ui/api/modules/sandbox/providers/modal.py

autonomous: true

must_haves:
  truths:
    - "SandboxProvider ABC defines the contract for all provider implementations"
    - "SandboxState enum defines all valid lifecycle states"
    - "Modal provider stub exists and raises NotImplementedError"
  artifacts:
    - path: "src/back/boring_ui/api/modules/sandbox/provider.py"
      provides: "Abstract SandboxProvider interface"
      exports: ["SandboxProvider", "SandboxState", "SandboxInfo"]
    - path: "src/back/boring_ui/api/modules/sandbox/__init__.py"
      provides: "Package exports"
      contains: "SandboxProvider"
    - path: "src/back/boring_ui/api/modules/sandbox/providers/modal.py"
      provides: "Modal provider stub"
      contains: "NotImplementedError"
  key_links:
    - from: "src/back/boring_ui/api/modules/sandbox/providers/modal.py"
      to: "SandboxProvider"
      via: "inheritance"
      pattern: "class ModalProvider\\(SandboxProvider\\)"
---

<objective>
Create the SandboxProvider abstract base class and supporting types that define the contract for sandbox execution providers.

Purpose: Establish the foundation interface that LocalProvider (and future ModalProvider) will implement. This enables a clean provider abstraction where the manager doesn't care about the underlying execution mechanism.

Output: provider.py with ABC, SandboxState enum, SandboxInfo dataclass; package __init__.py files; modal.py stub.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-backend-provider/01-CONTEXT.md
@.planning/phases/01-backend-provider/01-RESEARCH.md
@src/back/boring_ui/api/modules/pty/__init__.py
@src/back/boring_ui/api/modules/pty/service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SandboxProvider abstract interface and types</name>
  <files>
    src/back/boring_ui/api/modules/sandbox/provider.py
  </files>
  <action>
Create provider.py with:

1. SandboxState enum with values: STOPPED, STARTING, RUNNING, UNHEALTHY, STOPPING, FAILED

2. SandboxInfo dataclass with fields:
   - status: SandboxState
   - base_url: str
   - healthy: bool
   - pid: int | None
   - restart_count: int
   - last_health_check: datetime | None

3. SandboxProvider ABC with abstract methods:
   - async def start(self) -> None - Start sandbox, block until healthy or raise
   - async def stop(self) -> None - Stop sandbox gracefully (SIGTERM, then SIGKILL after 5s)
   - async def health_check(self) -> bool - Check if sandbox is healthy
   - async def get_logs(self, tail: int = 100) -> list[str] - Get recent log lines
   - async def stream_logs(self) -> AsyncIterator[str] - Stream logs in real-time
   - property base_url: str - Get sandbox base URL
   - property status: SandboxState - Get current state
   - async def get_info(self) -> SandboxInfo - Get full status info

Follow existing codebase patterns from PTYService. Use typing imports for AsyncIterator.
  </action>
  <verify>
python -c "from boring_ui.api.modules.sandbox.provider import SandboxProvider, SandboxState, SandboxInfo; print('OK')"
  </verify>
  <done>
SandboxProvider ABC with 8 abstract methods, SandboxState enum with 6 states, SandboxInfo dataclass all importable and type-correct.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create package __init__.py files and ModalProvider stub</name>
  <files>
    src/back/boring_ui/api/modules/sandbox/__init__.py
    src/back/boring_ui/api/modules/sandbox/providers/__init__.py
    src/back/boring_ui/api/modules/sandbox/providers/modal.py
  </files>
  <action>
Create three files:

1. sandbox/__init__.py - Package init that exports:
   - SandboxProvider, SandboxState, SandboxInfo from provider.py
   - (LocalProvider will be added in Plan 02)
   - (SandboxManager will be added in Plan 03)
   Follow existing PTY module pattern.

2. providers/__init__.py - Sub-package init that exports:
   - (LocalProvider will be added in Plan 02)
   - ModalProvider from modal.py
   Simple re-exports, nothing else.

3. providers/modal.py - ModalProvider stub class:
   - Inherit from SandboxProvider
   - Implement all abstract methods to raise NotImplementedError("Modal provider not yet implemented")
   - Add docstring: "Modal.com sandbox provider (future implementation)"
   - This is a placeholder for Phase 2+ work
  </action>
  <verify>
python -c "from boring_ui.api.modules.sandbox import SandboxProvider, SandboxState; from boring_ui.api.modules.sandbox.providers import ModalProvider; print('OK')"
  </verify>
  <done>
Package structure complete. sandbox module exportable. ModalProvider stub raises NotImplementedError on all methods.
  </done>
</task>

</tasks>

<verification>
Run from src/back directory:
```bash
cd src/back
python -c "
from boring_ui.api.modules.sandbox import SandboxProvider, SandboxState, SandboxInfo
from boring_ui.api.modules.sandbox.providers import ModalProvider
import inspect

# Verify SandboxProvider is ABC
assert inspect.isabstract(SandboxProvider), 'SandboxProvider must be abstract'

# Verify all abstract methods
expected = ['start', 'stop', 'health_check', 'get_logs', 'stream_logs', 'get_info']
for method in expected:
    assert hasattr(SandboxProvider, method), f'Missing method: {method}'

# Verify SandboxState
states = ['STOPPED', 'STARTING', 'RUNNING', 'UNHEALTHY', 'STOPPING', 'FAILED']
for state in states:
    assert hasattr(SandboxState, state), f'Missing state: {state}'

# Verify ModalProvider raises NotImplementedError
modal = ModalProvider()
try:
    import asyncio
    asyncio.run(modal.start())
    assert False, 'ModalProvider.start should raise'
except NotImplementedError:
    pass

print('All verifications passed')
"
```
</verification>

<success_criteria>
- [ ] SandboxProvider ABC exists with all 8 required methods/properties
- [ ] SandboxState enum has 6 states (STOPPED, STARTING, RUNNING, UNHEALTHY, STOPPING, FAILED)
- [ ] SandboxInfo dataclass has required fields (status, base_url, healthy, pid, restart_count, last_health_check)
- [ ] ModalProvider stub inherits SandboxProvider and raises NotImplementedError
- [ ] All imports work: `from boring_ui.api.modules.sandbox import SandboxProvider`
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-provider/01-01-SUMMARY.md`
</output>
